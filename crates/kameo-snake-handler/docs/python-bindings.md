# Generated Python Bindings (Typed)

This explains the generated Python modules produced at child start-up and how to use them safely with strict typing. Code is generated automatically from Rust types using a compile-time proc-macro (`#[derive(PythonIr)]`) and merged at runtime with any additional IR you include via the builder.

## Per-package generated files

- `invocation_generated_types.py`
  - Dataclasses for request/response structs and per-variant dataclasses for enums
  - Typed unions (e.g., `TestMessage`, `TestResponse`)
  - Helpers: `from_wire_*`, `to_wire_*`, `match_*`, `decode_*`, `is_*`, `expect_*`, `make_*`, enum constructors
- `callback_generated_types.py`
  - Async wrappers for typed callbacks: `module__handler(req: 'RequestType') -> AsyncGenerator['ResponseUnion', None]`
  - Forward-ref annotations and `TYPE_CHECKING` imports for precise typing
  - **Callback type definitions**: Dataclasses for Rust callback request and response structs, including `make_*`, `from_wire_*`, `to_wire_*`, `match_*` functions, type guards and constructors

Files are generated by `setup_python_subprocess_system!` before imports; do not vendor them.

**Note**: This results in only 2 generated files per package, making the structure cleaner and easier to manage.

## Mapping

- Rust `struct` → Python `@dataclass`
- Rust `enum` → Python `Union` of per-variant dataclasses (`kind: Literal[...]`)
- Maps/sequences → `Dict[str, T]` and `List[T]` (non-string keys fall back to `Any`)

## Enum helpers (example: `TestMessage`)

- Wire roundtrip: `from_wire_test_message(d)` / `to_wire_test_message(m)`
- Constructors: `make_test_message_variant(...)` and short aliases
- Matching: `match_test_message(m, **handlers: Unpack[TestMessageHandlers])`
- Guards: `is_*`, `expect_*`
- Decoder: `decode_test_message(tag, payload)`

## Struct helpers (example: `Config`)

- `make_config(...)`, `from_wire_config(d)`, `from_wire_config_strict(d)`, `to_wire_config(cfg)`

## Callback wrappers

```python
from . import callback_generated_types as cb
from .callback_generated_types import TestCallbackMessage, TestCallbackResponse

async def go() -> None:
    it = cb.test__test_callback(TestCallbackMessage(value=42))
    async for item in it:
        # item is now strictly typed as TestCallbackResponse
        if is_test_callback_response_success(item):
            print(f"Success: {item.result}")
        else:
            print(f"Error: {item.error}")
```

Wrappers include:
- `from __future__ import annotations`
- `# pyright: reportMissingImports=false`
- `import kameo  # type: ignore[import-not-found]`
- `if TYPE_CHECKING: from .callback_request_types import *`

## Usage patterns

Sync dispatch:
```python
from typing import Dict, Any
from . import invocation_generated_types as gen

def handle_message(message: Dict[str, Any]) -> Dict[str, Any]:
    m = gen.from_wire_test_message(message)
    def on_power(count: int) -> gen.TestResponse:
        return gen.test_response_power(power=int(count) * 2)
    resp = gen.match_test_message(
        m,
        CalculatePower=lambda count: on_power(int(count)),
        default=lambda _m: (_ for _ in ()).throw(ValueError("unknown")),
    )
    return gen.to_wire_test_response(resp)
```

Async + callbacks (fully typed example):
```python
from typing import Dict, Any, AsyncGenerator, Awaitable
from . import invocation_generated_types as gen
from . import callback_generated_types as cb
from .callback_generated_types import TestCallbackMessage

async def handle_message_async(message: Dict[str, Any]) -> Dict[str, Any]:
    # Parse wire dict to typed union
    tm: gen.TestMessage = gen.from_wire_test_message(message)

    async def on_callback_roundtrip(value: int) -> gen.TestResponse:
        # Strongly-typed generated callback request and iterator
        it: AsyncGenerator[gen.TestResponse, None] = cb.test__test_callback(
            TestCallbackMessage(value=int(value))
        )
        async for _ in it:
            break
        return gen.test_response_callback_roundtrip_result(value=int(value) + 1)

    # match_* returns either a value or awaitable depending on variant
    match_result: gen.TestResponse | Awaitable[gen.TestResponse] = gen.match_test_message(
        tm,
        CallbackRoundtrip=lambda value: on_callback_roundtrip(int(value)),
        default=lambda _m: (_ for _ in ()).throw(ValueError("unknown")),
    )
    resp: gen.TestResponse = await match_result if hasattr(match_result, "__await__") else match_result
    return gen.to_wire_test_response(resp)
```

## Best practices

- Never parse or dispatch manually; always use `from_wire_*` + `match_*` and `to_wire_*`
- Prefer `from_wire_*_strict` to reject unknown keys where appropriate
- Use generated `make_*` and constructors to build instances
- Call only via generated wrappers; avoid dynamic `getattr`

## How it works

- At compile time, you derive an intermediate representation by annotating Rust types with `#[derive(PythonIr)]`
- The parent process collects IR via the `ProvideIr` trait and passes it to the child through environment variables
- Child writes `invocation_generated_types.py` and `callback_generated_types.py` into each target package directory
- **Important**: Generated files are written to the package directory (e.g., `agentflow_agents/`) not the full module path (e.g., `agentflow_agents.a2a_agent/`)
- **Callback type generation**: Callback types are embedded directly into `callback_generated_types.py` whenever callback IR is provided via environment variables, regardless of whether callback handlers are registered in the callback registry.
- No runtime reflection is used; the IR is deterministic and generated at compile time

## Proc-macro usage

```rust
use serde::{Serialize, Deserialize};
use kameo_python_ir_derive::PythonIr;

#[derive(Serialize, Deserialize, PythonIr)]
pub enum MyMessage { /* ... */ }

#[derive(Serialize, Deserialize, PythonIr)]
pub enum MyResponse { /* ... */ }

// Optional: for callback request/response types
#[derive(Serialize, Deserialize, PythonIr)]
pub struct MyCallbackRequest { /* ... */ }
```

## Builder integration

```rust
use kameo_snake_handler::{PythonChildProcessBuilder, PythonConfig};

let builder = PythonChildProcessBuilder::<MyMessage>::new(python_config)
    // Include extra types (unions, shared models, etc.)
    .with_invocation_type::<MyResponse>(); // Any T: ProvideIr
```

## Troubleshooting

- Missing-import warnings on `kameo` are suppressed inside wrappers while preserving type fidelity
- Restart child when Rust types change to regenerate files
- Generated files are environment artifacts; do not commit them
- **Module path handling**: If your `module_name` contains dots (e.g., `"agentflow_agents.a2a_agent"`), generated files will be written to the package directory (`agentflow_agents/`), not the full module path. This ensures Python can properly import the generated types.
- **Missing callback types**: If you're not seeing callback types in `callback_generated_types.py`, check that your Rust types have `#[derive(PythonIr)]` and that the builder is calling `.with_callback_handler()`. The callback types are generated based on IR, not the callback registry.
