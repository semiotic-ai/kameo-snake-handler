# Generated Python Bindings (Typed)

This explains the generated Python modules produced at child start-up and how to use them safely with strict typing. Code is generated automatically from Rust types using serde-reflection; no application-side IR is required.

## Per-package generated files

- `invocation_generated_types.py`
  - Dataclasses for request/response structs and per-variant dataclasses for enums
  - Typed unions (e.g., `TestMessage`, `TestResponse`)
  - Helpers: `from_wire_*`, `to_wire_*`, `match_*`, `decode_*`, `is_*`, `expect_*`, `make_*`, enum constructors
- `callback_request_types.py`
  - Dataclasses for Rust callback request structs with `make_*`, `from_wire_*`, `from_wire_*_strict`, `to_wire_*`
- `callback_generated_types.py`
  - Async wrappers for typed callbacks: `module__handler(req: 'RequestType') -> AsyncGenerator['ResponseUnion', None]`
  - Forward-ref annotations and `TYPE_CHECKING` imports for precise typing

Files are generated by `setup_python_subprocess_system!` before imports; do not vendor them.

## Mapping

- Rust `struct` → Python `@dataclass`
- Rust `enum` → Python `Union` of per-variant dataclasses (`kind: Literal[...]`)
- Maps/sequences → `Dict[str, T]` and `List[T]` (non-string keys fall back to `Any`)

## Enum helpers (example: `TestMessage`)

- Wire roundtrip: `from_wire_test_message(d)` / `to_wire_test_message(m)`
- Constructors: `make_test_message_variant(...)` and short aliases
- Matching: `match_test_message(m, **handlers: Unpack[TestMessageHandlers])`
- Guards: `is_*`, `expect_*`
- Decoder: `decode_test_message(tag, payload)`

## Struct helpers (example: `Config`)

- `make_config(...)`, `from_wire_config(d)`, `from_wire_config_strict(d)`, `to_wire_config(cfg)`

## Callback wrappers

```python
from . import callback_generated_types as cb
from .callback_request_types import TestCallbackMessage

async def go() -> None:
    it = cb.test__test_callback(TestCallbackMessage(value=42))
    async for item in it:
        ...  # item: inv.TestResponse
```

Wrappers include:
- `from __future__ import annotations`
- `# pyright: reportMissingImports=false`
- `import kameo  # type: ignore[import-not-found]`
- `if TYPE_CHECKING: from .callback_request_types import *`

## Usage patterns

Sync dispatch:
```python
from typing import Dict, Any
from . import invocation_generated_types as gen

def handle_message(message: Dict[str, Any]) -> Dict[str, Any]:
    m = gen.from_wire_test_message(message)
    def on_power(count: int) -> gen.TestResponse:
        return gen.test_response_power(power=int(count) * 2)
    resp = gen.match_test_message(
        m,
        CalculatePower=lambda count: on_power(int(count)),
        default=lambda _m: (_ for _ in ()).throw(ValueError("unknown")),
    )
    return gen.to_wire_test_response(resp)
```

Async + callbacks (fully typed example):
```python
from typing import Dict, Any, AsyncGenerator, Awaitable
from . import invocation_generated_types as gen
from . import callback_generated_types as cb
from .callback_request_types import TestCallbackMessage

async def handle_message_async(message: Dict[str, Any]) -> Dict[str, Any]:
    # Parse wire dict to typed union
    tm: gen.TestMessage = gen.from_wire_test_message(message)

    async def on_callback_roundtrip(value: int) -> gen.TestResponse:
        # Strongly-typed generated callback request and iterator
        it: AsyncGenerator[gen.TestResponse, None] = cb.test__test_callback(
            TestCallbackMessage(value=int(value))
        )
        async for _ in it:
            break
        return gen.test_response_callback_roundtrip_result(value=int(value) + 1)

    # match_* returns either a value or awaitable depending on variant
    match_result: gen.TestResponse | Awaitable[gen.TestResponse] = gen.match_test_message(
        tm,
        CallbackRoundtrip=lambda value: on_callback_roundtrip(int(value)),
        default=lambda _m: (_ for _ in ()).throw(ValueError("unknown")),
    )
    resp: gen.TestResponse = await match_result if hasattr(match_result, "__await__") else match_result
    return gen.to_wire_test_response(resp)
```

## Best practices

- Never parse or dispatch manually; always use `from_wire_*` + `match_*` and `to_wire_*`
- Prefer `from_wire_*_strict` to reject unknown keys where appropriate
- Use generated `make_*` and constructors to build instances
- Call only via generated wrappers; avoid dynamic `getattr`

## How it works

- Parent derives an intermediate representation with serde-reflection and passes it to child
- Child writes `invocation_generated_types.py`, `callback_request_types.py`, `callback_generated_types.py` into each target package directory
- No application-side traits required

## Troubleshooting

- Missing-import warnings on `kameo` are suppressed inside wrappers while preserving type fidelity
- Restart child when Rust types change to regenerate files
- Generated files are environment artifacts; do not commit them
