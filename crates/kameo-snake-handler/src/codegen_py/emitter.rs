use std::fmt::Write as _;

use super::ir::{Decl, EnumDecl, EnumVariant, StructDecl, TypeRef};
use std::collections::HashSet;

/// Emit a single Python module string containing dataclasses and union definitions
/// for the given declarations. The output is intended to be saved to a .py file.
pub fn emit_python_module(package_name: &str, decls: &[Decl]) -> String {
    let mut out = String::new();

    // Header
    writeln!(out, "# Generated by kameo-snake-handler codegen. Do not edit.").unwrap();
    writeln!(out, "# package: {}", package_name).unwrap();
    writeln!(out, "from __future__ import annotations").unwrap();
    writeln!(out, "from dataclasses import dataclass").unwrap();
    writeln!(out, "from typing import Optional, Union, Literal, List, Dict, Any, Callable, TypeVar, TypedDict, Unpack").unwrap();
    writeln!(out, "try:").unwrap();
    writeln!(out, "    from typing import TypeGuard  # Python 3.10+").unwrap();
    writeln!(out, "except ImportError:").unwrap();
    writeln!(out, "    from typing_extensions import TypeGuard  # fallback").unwrap();
    writeln!(out).unwrap();

    // Deduplicate declarations by name to avoid redefinitions
    let mut seen: HashSet<String> = HashSet::new();
    let mut unique: Vec<&Decl> = Vec::new();
    for d in decls {
        let name = match d { Decl::Struct(s) => &s.name, Decl::Enum(e) => &e.name };
        if seen.insert(name.clone()) { unique.push(d); }
    }

    // Forward declare names for typing self-references
    for decl in &unique {
        match decl {
            Decl::Struct(s) => {
                writeln!(out, "class {}: ...", s.name).unwrap();
            }
            Decl::Enum(e) => {
                writeln!(out, "class {}: ...", e.name).unwrap();
            }
        }
    }
    writeln!(out).unwrap();

    // Emit structs and enum variant dataclasses
    for decl in &unique {
        match decl {
            Decl::Struct(s) => emit_struct(&mut out, s),
            Decl::Enum(e) => emit_enum(&mut out, e),
        }
        writeln!(out).unwrap();
    }

    out
}

fn emit_struct(out: &mut String, s: &StructDecl) {
    writeln!(out, "@dataclass").unwrap();
    writeln!(out, "class {}:", s.name).unwrap();
    if s.fields.is_empty() {
        writeln!(out, "    pass").unwrap();
        return;
    }
    for (field, ty) in &s.fields {
        writeln!(out, "    {}: {}", field, py_type(ty)).unwrap();
    }

    // Helpers: make_*, from_wire_*, to_wire_*
    let snake = to_snake(&s.name);
    // make_* constructor
    let args: String = s.fields.iter().map(|(f, _)| f.clone()).collect::<Vec<_>>().join(", ");
    writeln!(out, "def make_{}({}) -> {}:", snake, args, s.name).unwrap();
    let kwargs: String = s.fields.iter().map(|(f, _)| format!("{}={}", f, f)).collect::<Vec<_>>().join(", ");
    writeln!(out, "    return {}({})", s.name, kwargs).unwrap();

    // from_wire_* recursively parses nested fields from wire
    writeln!(out, "def from_wire_{}(d: Dict[str, Any]) -> {}:", snake, s.name).unwrap();
    writeln!(out, "    if not isinstance(d, dict):").unwrap();
    writeln!(out, "        raise ValueError(\"Invalid {} wire shape: expected dict\")", s.name).unwrap();
    // build args; for now, accept missing optional values as None
    let mut assigns: Vec<String> = Vec::new();
    for (f, ty) in &s.fields {
        let src = format!("d.get(\"{}\")", f);
        let expr = from_wire_expr(ty, &src);
        assigns.push(format!("{}={}", f, expr));
    }
    writeln!(out, "    return {}({})", s.name, assigns.join(", ")).unwrap();

    // to_wire_* recursively serializes nested fields to wire
    writeln!(out, "def to_wire_{}(m: {}) -> Dict[str, Any]:", snake, s.name).unwrap();
    let mut map_entries: Vec<String> = Vec::new();
    for (f, ty) in &s.fields {
        let src = format!("m.{}", f);
        let expr = to_wire_expr(ty, &src);
        map_entries.push(format!("\"{}\": {}", f, expr));
    }
    writeln!(out, "    return {{{}}}", map_entries.join(", ")).unwrap();

    // strict variant: reject unknown keys
    writeln!(out, "def from_wire_{}_strict(d: Dict[str, Any]) -> {}:", snake, s.name).unwrap();
    writeln!(out, "    if not isinstance(d, dict):").unwrap();
    writeln!(out, "        raise ValueError(\"Invalid {} wire shape: expected dict\")", s.name).unwrap();
    writeln!(out, "    allowed = {{{}}}", s.fields.iter().map(|(f, _)| format!("\"{}\"", f)).collect::<Vec<_>>().join(", ")).unwrap();
    writeln!(out, "    unknown = set(d.keys()) - allowed").unwrap();
    writeln!(out, "    if unknown:").unwrap();
    writeln!(out, "        raise ValueError(\"Unknown keys for {}: \" + repr(unknown))", s.name).unwrap();
    writeln!(out, "    return from_wire_{}(d)", snake).unwrap();
}

fn emit_enum(out: &mut String, e: &EnumDecl) {
    let mut variant_type_names: Vec<String> = Vec::new();
    let enum_snake = to_snake(&e.name);
    for v in &e.variants {
        match v {
            EnumVariant::Unit { name } => {
                let vt = format!("{}{}", e.name, name);
                variant_type_names.push(vt.clone());
                writeln!(out, "@dataclass").unwrap();
                writeln!(out, "class {}:", vt).unwrap();
                writeln!(out, "    kind: Literal[\"{}\"]", name).unwrap();
                writeln!(out).unwrap();
            }
            EnumVariant::Newtype { name, ty } => {
                let vt = format!("{}{}", e.name, name);
                variant_type_names.push(vt.clone());
                writeln!(out, "@dataclass").unwrap();
                writeln!(out, "class {}:", vt).unwrap();
                writeln!(out, "    kind: Literal[\"{}\"]", name).unwrap();
                writeln!(out, "    value: {}", py_type(ty)).unwrap();
                writeln!(out).unwrap();
            }
            EnumVariant::Tuple { name, tys } => {
                let vt = format!("{}{}", e.name, name);
                variant_type_names.push(vt.clone());
                writeln!(out, "@dataclass").unwrap();
                writeln!(out, "class {}:", vt).unwrap();
                writeln!(out, "    kind: Literal[\"{}\"]", name).unwrap();
                for (i, ty) in tys.iter().enumerate() {
                    writeln!(out, "    field_{}: {}", i, py_type(ty)).unwrap();
                }
                writeln!(out).unwrap();
            }
            EnumVariant::Struct { name, fields } => {
                let vt = format!("{}{}", e.name, name);
                variant_type_names.push(vt.clone());
                writeln!(out, "@dataclass").unwrap();
                writeln!(out, "class {}:", vt).unwrap();
                writeln!(out, "    kind: Literal[\"{}\"]", name).unwrap();
                for (fname, fty) in fields {
                    writeln!(out, "    {}: {}", fname, py_type(fty)).unwrap();
                }
                writeln!(out).unwrap();
            }
        }
    }

    // Top-level union alias
    write!(out, "{} = Union[", e.name).unwrap();
    for (i, vt) in variant_type_names.iter().enumerate() {
        if i > 0 {
            write!(out, ", ").unwrap();
        }
        write!(out, "{}", vt).unwrap();
    }
    writeln!(out, "]").unwrap();

    // TypeVar for match
    writeln!(out, "R = TypeVar(\"R\")").unwrap();

    // Generate is_* and expect_* helpers
    for v in &e.variants {
        match v {
            EnumVariant::Unit { name } => {
                let vt = format!("{}{}", e.name, name);
                writeln!(out, "def is_{}_{}(m: {}) -> TypeGuard[{}]:", enum_snake, to_snake(name), e.name, vt).unwrap();
                writeln!(out, "    return isinstance(m, {})", vt).unwrap();
                writeln!(out).unwrap();
                writeln!(out, "def expect_{}_{}(m: {}) -> {}:", enum_snake, to_snake(name), e.name, vt).unwrap();
                writeln!(out, "    if not isinstance(m, {}):", vt).unwrap();
                writeln!(out, "        raise TypeError(f\"Expected {}{}, got {{m!r}}\")", e.name, name).unwrap();
                writeln!(out, "    return m").unwrap();
                writeln!(out).unwrap();
            }
            EnumVariant::Newtype { name, .. } => {
                let vt = format!("{}{}", e.name, name);
                writeln!(out, "def is_{}_{}(m: {}) -> TypeGuard[{}]:", enum_snake, to_snake(name), e.name, vt).unwrap();
                writeln!(out, "    return isinstance(m, {})", vt).unwrap();
                writeln!(out).unwrap();
                writeln!(out, "def expect_{}_{}(m: {}) -> {}:", enum_snake, to_snake(name), e.name, vt).unwrap();
                writeln!(out, "    if not isinstance(m, {}):", vt).unwrap();
                writeln!(out, "        raise TypeError(f\"Expected {}{}, got {{m!r}}\")", e.name, name).unwrap();
                writeln!(out, "    return m").unwrap();
                writeln!(out).unwrap();
            }
            EnumVariant::Tuple { name, .. } => {
                let vt = format!("{}{}", e.name, name);
                writeln!(out, "def is_{}_{}(m: {}) -> TypeGuard[{}]:", enum_snake, to_snake(name), e.name, vt).unwrap();
                writeln!(out, "    return isinstance(m, {})", vt).unwrap();
                writeln!(out).unwrap();
                writeln!(out, "def expect_{}_{}(m: {}) -> {}:", enum_snake, to_snake(name), e.name, vt).unwrap();
                writeln!(out, "    if not isinstance(m, {}):", vt).unwrap();
                writeln!(out, "        raise TypeError(f\"Expected {}{}, got {{m!r}}\")", e.name, name).unwrap();
                writeln!(out, "    return m").unwrap();
                writeln!(out).unwrap();
            }
            EnumVariant::Struct { name, .. } => {
                let vt = format!("{}{}", e.name, name);
                writeln!(out, "def is_{}_{}(m: {}) -> TypeGuard[{}]:", enum_snake, to_snake(name), e.name, vt).unwrap();
                writeln!(out, "    return isinstance(m, {})", vt).unwrap();
                writeln!(out).unwrap();
                writeln!(out, "def expect_{}_{}(m: {}) -> {}:", enum_snake, to_snake(name), e.name, vt).unwrap();
                writeln!(out, "    if not isinstance(m, {}):", vt).unwrap();
                writeln!(out, "        raise TypeError(f\"Expected {}{}, got {{m!r}}\")", e.name, name).unwrap();
                writeln!(out, "    return m").unwrap();
                writeln!(out).unwrap();
            }
        }
    }

    // Constructors (emit both legacy names and unified make_* helpers)
    for v in &e.variants {
        match v {
            EnumVariant::Unit { name } => {
                let vt = format!("{}{}", e.name, name);
                // unified helper
                writeln!(out, "def make_{}_{}() -> {}:", enum_snake, to_snake(name), e.name).unwrap();
                writeln!(out, "    return {}(kind=\"{}\")", vt, name).unwrap();
                writeln!(out).unwrap();
                // legacy alias
                writeln!(out, "def {}_{}() -> {}:", enum_snake, to_snake(name), e.name).unwrap();
                writeln!(out, "    return make_{}_{}()", enum_snake, to_snake(name)).unwrap();
                writeln!(out).unwrap();
            }
            EnumVariant::Newtype { name, .. } => {
                let vt = format!("{}{}", e.name, name);
                // unified helper
                writeln!(out, "def make_{}_{}(value) -> {}:", enum_snake, to_snake(name), e.name).unwrap();
                writeln!(out, "    return {}(kind=\"{}\", value=value)", vt, name).unwrap();
                writeln!(out).unwrap();
                // legacy alias
                writeln!(out, "def {}_{}(value) -> {}:", enum_snake, to_snake(name), e.name).unwrap();
                writeln!(out, "    return make_{}_{}(value)", enum_snake, to_snake(name)).unwrap();
                writeln!(out).unwrap();
            }
            EnumVariant::Tuple { name, tys } => {
                let vt = format!("{}{}", e.name, name);
                let args: String = (0..tys.len()).map(|i| format!("field_{}", i)).collect::<Vec<_>>().join(", ");
                // unified helper
                writeln!(out, "def make_{}_{}({}) -> {}:", enum_snake, to_snake(name), args, e.name).unwrap();
                let kwargs: String = (0..tys.len()).map(|i| format!("field_{}=field_{}", i, i)).collect::<Vec<_>>().join(", ");
                writeln!(out, "    return {}(kind=\"{}\", {})", vt, name, kwargs).unwrap();
                writeln!(out).unwrap();
                // legacy alias
                writeln!(out, "def {}_{}({}) -> {}:", enum_snake, to_snake(name), args, e.name).unwrap();
                writeln!(out, "    return make_{}_{}({})", enum_snake, to_snake(name), args).unwrap();
                writeln!(out).unwrap();
            }
            EnumVariant::Struct { name, fields } => {
                let vt = format!("{}{}", e.name, name);
                let args: String = fields.iter().map(|(f, _)| f.clone()).collect::<Vec<_>>().join(", ");
                // unified helper
                writeln!(out, "def make_{}_{}({}) -> {}:", enum_snake, to_snake(name), args, e.name).unwrap();
                let kwargs: String = fields.iter().map(|(f, _)| format!("{}={}", f, f)).collect::<Vec<_>>().join(", ");
                writeln!(out, "    return {}(kind=\"{}\", {})", vt, name, kwargs).unwrap();
                writeln!(out).unwrap();
                // legacy alias
                writeln!(out, "def {}_{}({}) -> {}:", enum_snake, to_snake(name), args, e.name).unwrap();
                writeln!(out, "    return make_{}_{}({})", enum_snake, to_snake(name), args).unwrap();
                writeln!(out).unwrap();
            }
        }
    }

    // from_wire_* and to_wire_* (recursive)
    writeln!(out, "def from_wire_{}(d: Dict[str, Any]) -> {}:", enum_snake, e.name).unwrap();
    writeln!(out, "    if not isinstance(d, dict) or len(d) != 1:").unwrap();
    writeln!(out, "        raise ValueError(\"Invalid {} wire shape: {{!r}}\".format(d))", e.name).unwrap();
    writeln!(out, "    tag, payload = next(iter(d.items()))").unwrap();
    for v in &e.variants {
        match v {
            EnumVariant::Unit { name } => {
                let vt = format!("{}{}", e.name, name);
                writeln!(out, "    if tag == \"{}\":", name).unwrap();
                writeln!(out, "        if payload not in ({{}}, None):").unwrap();
                writeln!(out, "            raise ValueError(\"Unit variant expects empty payload\")").unwrap();
                writeln!(out, "        return {}(kind=\"{}\")", vt, name).unwrap();
            }
            EnumVariant::Newtype { name, ty } => {
                let vt = format!("{}{}", e.name, name);
                writeln!(out, "    if tag == \"{}\":", name).unwrap();
                let expr = from_wire_expr(ty, "payload");
                writeln!(out, "        return {}(kind=\"{}\", value={})", vt, name, expr).unwrap();
            }
            EnumVariant::Tuple { name, tys } => {
                let vt = format!("{}{}", e.name, name);
                let len_expected = tys.len();
                writeln!(out, "    if tag == \"{}\":", name).unwrap();
                writeln!(out, "        if not isinstance(payload, (list, tuple)) or len(payload) != {}:", len_expected).unwrap();
                writeln!(out, "            raise ValueError(\"Tuple payload arity mismatch\")").unwrap();
                let assigns: String = (0..len_expected).map(|i| {
                    let expr = from_wire_expr(&tys[i], &format!("payload[{}]", i));
                    format!("field_{}={}", i, expr)
                }).collect::<Vec<_>>().join(", ");
                writeln!(out, "        return {}(kind=\"{}\", {})", vt, name, assigns).unwrap();
            }
            EnumVariant::Struct { name, fields } => {
                let vt = format!("{}{}", e.name, name);
                writeln!(out, "    if tag == \"{}\":", name).unwrap();
                writeln!(out, "        if not isinstance(payload, dict):").unwrap();
                writeln!(out, "            raise ValueError(\"Struct payload must be a dict\")").unwrap();
                let assigns: String = fields.iter().map(|(f, fty)| {
                    let expr = from_wire_expr(fty, &format!("payload.get(\"{}\")", f));
                    format!("{}={}", f, expr)
                }).collect::<Vec<_>>().join(", ");
                writeln!(out, "        return {}(kind=\"{}\", {})", vt, name, assigns).unwrap();
            }
        }
    }
    writeln!(out, "    raise ValueError(f\"Unknown {} tag: {{tag!r}}\")", e.name).unwrap();
    writeln!(out).unwrap();

    writeln!(out, "def to_wire_{}(m: {}) -> Dict[str, Any]:", enum_snake, e.name).unwrap();
    for v in &e.variants {
        match v {
            EnumVariant::Unit { name } => {
                let vt = format!("{}{}", e.name, name);
                writeln!(out, "    if isinstance(m, {}):", vt).unwrap();
                writeln!(out, "        return {{\"{}\": {{}}}}", name).unwrap();
            }
            EnumVariant::Newtype { name, ty } => {
                let vt = format!("{}{}", e.name, name);
                writeln!(out, "    if isinstance(m, {}):", vt).unwrap();
                let expr = to_wire_expr(ty, "m.value");
                writeln!(out, "        return {{\"{}\": {}}}", name, expr).unwrap();
            }
            EnumVariant::Tuple { name, tys } => {
                let vt = format!("{}{}", e.name, name);
                let arr: String = (0..tys.len()).map(|i| {
                    to_wire_expr(&tys[i], &format!("m.field_{}", i))
                }).collect::<Vec<_>>().join(", ");
                writeln!(out, "    if isinstance(m, {}):", vt).unwrap();
                writeln!(out, "        return {{\"{}\": [{}]}}", name, arr).unwrap();
            }
            EnumVariant::Struct { name, fields } => {
                let vt = format!("{}{}", e.name, name);
                let map_entries: String = fields.iter().map(|(f, fty)| {
                    let expr = to_wire_expr(fty, &format!("m.{}", f));
                    format!("\"{}\": {}", f, expr)
                }).collect::<Vec<_>>().join(", ");
                writeln!(out, "    if isinstance(m, {}):", vt).unwrap();
                writeln!(out, "        return {{\"{}\": {{{}}}}}", name, map_entries).unwrap();
            }
        }
    }
    writeln!(out, "    raise TypeError(f\"Not a {} instance: {{m!r}}\")", e.name).unwrap();
    writeln!(out).unwrap();

    // TypedDict for handlers (under TYPE_CHECKING keep editors happy, at runtime it's fine)
    writeln!(out, "class {}Handlers(TypedDict, total=False):", e.name).unwrap();
    for v in &e.variants {
        match v {
            EnumVariant::Unit { name } => {
                writeln!(out, "    {}: Callable[[], R]", name).unwrap();
            }
            EnumVariant::Newtype { name, .. } => {
                writeln!(out, "    {}: Callable[[Any], R]", name).unwrap();
            }
            EnumVariant::Tuple { name, tys } => {
                let arity = tys.len();
                let args = std::iter::repeat_n("Any", arity).collect::<Vec<_>>().join(", ");
                writeln!(out, "    {}: Callable[[{}], R]", name, args).unwrap();
            }
            EnumVariant::Struct { name, fields } => {
                let args = fields.iter().map(|_| "Any").collect::<Vec<_>>().join(", ");
                writeln!(out, "    {}: Callable[[{}], R]", name, args).unwrap();
            }
        }
    }
    writeln!(out, "    default: Callable[[{}], R]", e.name).unwrap();

    // match function with Unpack typing
    writeln!(out, "def match_{}(m: {}, **handlers: Unpack[{}Handlers]) -> Any:", enum_snake, e.name, e.name).unwrap();
    for v in &e.variants {
        match v {
            EnumVariant::Unit { name } => {
                let vt = format!("{}{}", e.name, name);
                writeln!(out, "    if isinstance(m, {}):", vt).unwrap();
                writeln!(out, "        fn = handlers.get(\"{}\")", name).unwrap();
                writeln!(out, "        if fn is None:").unwrap();
                writeln!(out, "            default = handlers.get(\"default\")").unwrap();
                writeln!(out, "            return default(m) if default else (_ for _ in ()).throw(TypeError(\"No handler for {}\"))", name).unwrap();
                writeln!(out, "        return fn()").unwrap();
            }
            EnumVariant::Newtype { name, .. } => {
                let vt = format!("{}{}", e.name, name);
                writeln!(out, "    if isinstance(m, {}):", vt).unwrap();
                writeln!(out, "        fn = handlers.get(\"{}\")", name).unwrap();
                writeln!(out, "        if fn is None:").unwrap();
                writeln!(out, "            default = handlers.get(\"default\")").unwrap();
                writeln!(out, "            return default(m) if default else (_ for _ in ()).throw(TypeError(\"No handler for {}\"))", name).unwrap();
                writeln!(out, "        return fn(m.value)").unwrap();
            }
            EnumVariant::Tuple { name, tys } => {
                let vt = format!("{}{}", e.name, name);
                let args: String = (0..tys.len()).map(|i| format!("m.field_{}", i)).collect::<Vec<_>>().join(", ");
                writeln!(out, "    if isinstance(m, {}):", vt).unwrap();
                writeln!(out, "        fn = handlers.get(\"{}\")", name).unwrap();
                writeln!(out, "        if fn is None:").unwrap();
                writeln!(out, "            default = handlers.get(\"default\")").unwrap();
                writeln!(out, "            return default(m) if default else (_ for _ in ()).throw(TypeError(\"No handler for {}\"))", name).unwrap();
                writeln!(out, "        return fn({})", args).unwrap();
            }
            EnumVariant::Struct { name, fields } => {
                let vt = format!("{}{}", e.name, name);
                let args: String = fields.iter().map(|(f, _)| format!("m.{}", f)).collect::<Vec<_>>().join(", ");
                writeln!(out, "    if isinstance(m, {}):", vt).unwrap();
                writeln!(out, "        fn = handlers.get(\"{}\")", name).unwrap();
                writeln!(out, "        if fn is None:").unwrap();
                writeln!(out, "            default = handlers.get(\"default\")").unwrap();
                writeln!(out, "            return default(m) if default else (_ for _ in ()).throw(TypeError(\"No handler for {}\"))", name).unwrap();
                writeln!(out, "        return fn({})", args).unwrap();
            }
        }
    }
    writeln!(out, "    default = handlers.get(\"default\")").unwrap();
    writeln!(out, "    return default(m) if default else (_ for _ in ()).throw(TypeError(\"No matching handler\"))").unwrap();

    // decode(tag, payload) helper (recursive)
    writeln!(out, "def decode_{}(tag: str, payload: Any) -> {}:", enum_snake, e.name).unwrap();
    for v in &e.variants {
        match v {
            EnumVariant::Unit { name } => {
                let vt = format!("{}{}", e.name, name);
                writeln!(out, "    if tag == \"{}\":", name).unwrap();
                writeln!(out, "        return {}(kind=\"{}\")", vt, name).unwrap();
            }
            EnumVariant::Newtype { name, ty } => {
                let vt = format!("{}{}", e.name, name);
                writeln!(out, "    if tag == \"{}\":", name).unwrap();
                let expr = from_wire_expr(ty, "payload");
                writeln!(out, "        return {}(kind=\"{}\", value={})", vt, name, expr).unwrap();
            }
            EnumVariant::Tuple { name, tys } => {
                let vt = format!("{}{}", e.name, name);
                let assigns: String = (0..tys.len()).map(|i| {
                    let expr = from_wire_expr(&tys[i], &format!("payload[{}]", i));
                    format!("field_{}={}", i, expr)
                }).collect::<Vec<_>>().join(", ");
                writeln!(out, "    if tag == \"{}\":", name).unwrap();
                writeln!(out, "        return {}(kind=\"{}\", {})", vt, name, assigns).unwrap();
            }
            EnumVariant::Struct { name, fields } => {
                let vt = format!("{}{}", e.name, name);
                let assigns: String = fields.iter().map(|(f, fty)| {
                    let expr = from_wire_expr(fty, &format!("payload.get(\"{}\")", f));
                    format!("{}={}", f, expr)
                }).collect::<Vec<_>>().join(", ");
                writeln!(out, "    if tag == \"{}\":", name).unwrap();
                writeln!(out, "        return {}(kind=\"{}\", {})", vt, name, assigns).unwrap();
            }
        }
    }
    writeln!(out, "    raise ValueError(f\"Unknown {} tag: {{tag!r}}\")", e.name).unwrap();
}

// --- helpers to generate recursive from_wire/to_wire expressions ---
fn from_wire_expr(t: &TypeRef, src: &str) -> String {
    match t {
        TypeRef::Builtin(_) => src.to_string(),
        TypeRef::Named(n) => format!("from_wire_{}({})", to_snake(n), src),
        TypeRef::Option(inner) => {
            let inner_expr = from_wire_expr(inner, src);
            format!("({s} if {s} is None else {inner})", s = src, inner = inner_expr)
        }
        TypeRef::List(inner) => {
            let body = from_wire_expr(inner, "__x");
            format!("[{body} for __x in {src}]", body = body, src = src)
        }
        TypeRef::Dict(inner) => {
            let body = from_wire_expr(inner, "__v");
            format!("{{k: {body} for (k, __v) in {src}.items()}}", body = body, src = src)
        }
    }
}

fn to_wire_expr(t: &TypeRef, src: &str) -> String {
    match t {
        TypeRef::Builtin(_) => src.to_string(),
        TypeRef::Named(n) => format!("to_wire_{}({})", to_snake(n), src),
        TypeRef::Option(inner) => {
            let inner_expr = to_wire_expr(inner, src);
            format!("({s} if {s} is None else {inner})", s = src, inner = inner_expr)
        }
        TypeRef::List(inner) => {
            let body = to_wire_expr(inner, "__x");
            format!("[{body} for __x in {src}]", body = body, src = src)
        }
        TypeRef::Dict(inner) => {
            let body = to_wire_expr(inner, "__v");
            format!("{{k: {body} for (k, __v) in {src}.items()}}", body = body, src = src)
        }
    }
}

fn py_type(t: &TypeRef) -> String {
    match t {
        TypeRef::Builtin(b) => match b.as_str() {
            "int" => "int".to_string(),
            "float" => "float".to_string(),
            "bool" => "bool".to_string(),
            "str" => "str".to_string(),
            "bytes" => "bytes".to_string(),
            _ => "Any".to_string(),
        },
        TypeRef::Option(inner) => format!("Optional[{}]", py_type(inner)),
        TypeRef::List(inner) => format!("List[{}]", py_type(inner)),
        TypeRef::Dict(inner) => format!("Dict[str, {}]", py_type(inner)),
        TypeRef::Named(n) => n.clone(),
    }
}

fn to_snake(name: &str) -> String {
    let mut out = String::with_capacity(name.len() * 2);
    for (i, ch) in name.chars().enumerate() {
        if ch.is_uppercase() {
            if i > 0 {
                out.push('_');
            }
            for lc in ch.to_lowercase() {
                out.push(lc);
            }
        } else {
            out.push(ch);
        }
    }
    out
}


