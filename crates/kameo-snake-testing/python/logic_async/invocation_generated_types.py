# Generated by kameo-snake-handler codegen. Do not edit.
# package: invocation_generated_types
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Union, Literal, List, Dict, Any, Callable, TypeVar, TypedDict, Unpack
try:
    from typing import TypeGuard  # Python 3.10+
except ImportError:
    from typing_extensions import TypeGuard  # fallback

class TestMessage: ...
class TestResponse: ...

@dataclass
class TestMessageCalculatePower:
    kind: Literal["CalculatePower"]
    count: int

@dataclass
class TestMessageCalculateCategoryBonus:
    kind: Literal["CalculateCategoryBonus"]
    category_name: str
    base_power: int

@dataclass
class TestMessageCalculateCompetitionResult:
    kind: Literal["CalculateCompetitionResult"]
    attacker_power: int
    defender_power: int

@dataclass
class TestMessageCalculateReward:
    kind: Literal["CalculateReward"]
    currency: int
    points: int

@dataclass
class TestMessageCallbackRoundtrip:
    kind: Literal["CallbackRoundtrip"]
    value: int

@dataclass
class TestMessageStreamFibonacci:
    kind: Literal["StreamFibonacci"]
    count: int

@dataclass
class TestMessageStreamRandomNumbers:
    kind: Literal["StreamRandomNumbers"]
    count: int
    max_value: int

@dataclass
class TestMessageStreamWithDelays:
    kind: Literal["StreamWithDelays"]
    count: int
    delay_ms: int

@dataclass
class TestMessageStreamWithErrors:
    kind: Literal["StreamWithErrors"]
    count: int
    error_at: Optional[int]

@dataclass
class TestMessageStreamLargeDataset:
    kind: Literal["StreamLargeDataset"]
    count: int

TestMessage = Union[TestMessageCalculatePower, TestMessageCalculateCategoryBonus, TestMessageCalculateCompetitionResult, TestMessageCalculateReward, TestMessageCallbackRoundtrip, TestMessageStreamFibonacci, TestMessageStreamRandomNumbers, TestMessageStreamWithDelays, TestMessageStreamWithErrors, TestMessageStreamLargeDataset]
R = TypeVar("R")
def is_test_message_calculate_power(m: TestMessage) -> TypeGuard[TestMessageCalculatePower]:
    return isinstance(m, TestMessageCalculatePower)

def expect_test_message_calculate_power(m: TestMessage) -> TestMessageCalculatePower:
    if not isinstance(m, TestMessageCalculatePower):
        raise TypeError(f"Expected TestMessageCalculatePower, got {m!r}")
    return m

def is_test_message_calculate_category_bonus(m: TestMessage) -> TypeGuard[TestMessageCalculateCategoryBonus]:
    return isinstance(m, TestMessageCalculateCategoryBonus)

def expect_test_message_calculate_category_bonus(m: TestMessage) -> TestMessageCalculateCategoryBonus:
    if not isinstance(m, TestMessageCalculateCategoryBonus):
        raise TypeError(f"Expected TestMessageCalculateCategoryBonus, got {m!r}")
    return m

def is_test_message_calculate_competition_result(m: TestMessage) -> TypeGuard[TestMessageCalculateCompetitionResult]:
    return isinstance(m, TestMessageCalculateCompetitionResult)

def expect_test_message_calculate_competition_result(m: TestMessage) -> TestMessageCalculateCompetitionResult:
    if not isinstance(m, TestMessageCalculateCompetitionResult):
        raise TypeError(f"Expected TestMessageCalculateCompetitionResult, got {m!r}")
    return m

def is_test_message_calculate_reward(m: TestMessage) -> TypeGuard[TestMessageCalculateReward]:
    return isinstance(m, TestMessageCalculateReward)

def expect_test_message_calculate_reward(m: TestMessage) -> TestMessageCalculateReward:
    if not isinstance(m, TestMessageCalculateReward):
        raise TypeError(f"Expected TestMessageCalculateReward, got {m!r}")
    return m

def is_test_message_callback_roundtrip(m: TestMessage) -> TypeGuard[TestMessageCallbackRoundtrip]:
    return isinstance(m, TestMessageCallbackRoundtrip)

def expect_test_message_callback_roundtrip(m: TestMessage) -> TestMessageCallbackRoundtrip:
    if not isinstance(m, TestMessageCallbackRoundtrip):
        raise TypeError(f"Expected TestMessageCallbackRoundtrip, got {m!r}")
    return m

def is_test_message_stream_fibonacci(m: TestMessage) -> TypeGuard[TestMessageStreamFibonacci]:
    return isinstance(m, TestMessageStreamFibonacci)

def expect_test_message_stream_fibonacci(m: TestMessage) -> TestMessageStreamFibonacci:
    if not isinstance(m, TestMessageStreamFibonacci):
        raise TypeError(f"Expected TestMessageStreamFibonacci, got {m!r}")
    return m

def is_test_message_stream_random_numbers(m: TestMessage) -> TypeGuard[TestMessageStreamRandomNumbers]:
    return isinstance(m, TestMessageStreamRandomNumbers)

def expect_test_message_stream_random_numbers(m: TestMessage) -> TestMessageStreamRandomNumbers:
    if not isinstance(m, TestMessageStreamRandomNumbers):
        raise TypeError(f"Expected TestMessageStreamRandomNumbers, got {m!r}")
    return m

def is_test_message_stream_with_delays(m: TestMessage) -> TypeGuard[TestMessageStreamWithDelays]:
    return isinstance(m, TestMessageStreamWithDelays)

def expect_test_message_stream_with_delays(m: TestMessage) -> TestMessageStreamWithDelays:
    if not isinstance(m, TestMessageStreamWithDelays):
        raise TypeError(f"Expected TestMessageStreamWithDelays, got {m!r}")
    return m

def is_test_message_stream_with_errors(m: TestMessage) -> TypeGuard[TestMessageStreamWithErrors]:
    return isinstance(m, TestMessageStreamWithErrors)

def expect_test_message_stream_with_errors(m: TestMessage) -> TestMessageStreamWithErrors:
    if not isinstance(m, TestMessageStreamWithErrors):
        raise TypeError(f"Expected TestMessageStreamWithErrors, got {m!r}")
    return m

def is_test_message_stream_large_dataset(m: TestMessage) -> TypeGuard[TestMessageStreamLargeDataset]:
    return isinstance(m, TestMessageStreamLargeDataset)

def expect_test_message_stream_large_dataset(m: TestMessage) -> TestMessageStreamLargeDataset:
    if not isinstance(m, TestMessageStreamLargeDataset):
        raise TypeError(f"Expected TestMessageStreamLargeDataset, got {m!r}")
    return m

def make_test_message_calculate_power(count) -> TestMessage:
    return TestMessageCalculatePower(kind="CalculatePower", count=count)

def test_message_calculate_power(count) -> TestMessage:
    return make_test_message_calculate_power(count)

def make_test_message_calculate_category_bonus(category_name, base_power) -> TestMessage:
    return TestMessageCalculateCategoryBonus(kind="CalculateCategoryBonus", category_name=category_name, base_power=base_power)

def test_message_calculate_category_bonus(category_name, base_power) -> TestMessage:
    return make_test_message_calculate_category_bonus(category_name, base_power)

def make_test_message_calculate_competition_result(attacker_power, defender_power) -> TestMessage:
    return TestMessageCalculateCompetitionResult(kind="CalculateCompetitionResult", attacker_power=attacker_power, defender_power=defender_power)

def test_message_calculate_competition_result(attacker_power, defender_power) -> TestMessage:
    return make_test_message_calculate_competition_result(attacker_power, defender_power)

def make_test_message_calculate_reward(currency, points) -> TestMessage:
    return TestMessageCalculateReward(kind="CalculateReward", currency=currency, points=points)

def test_message_calculate_reward(currency, points) -> TestMessage:
    return make_test_message_calculate_reward(currency, points)

def make_test_message_callback_roundtrip(value) -> TestMessage:
    return TestMessageCallbackRoundtrip(kind="CallbackRoundtrip", value=value)

def test_message_callback_roundtrip(value) -> TestMessage:
    return make_test_message_callback_roundtrip(value)

def make_test_message_stream_fibonacci(count) -> TestMessage:
    return TestMessageStreamFibonacci(kind="StreamFibonacci", count=count)

def test_message_stream_fibonacci(count) -> TestMessage:
    return make_test_message_stream_fibonacci(count)

def make_test_message_stream_random_numbers(count, max_value) -> TestMessage:
    return TestMessageStreamRandomNumbers(kind="StreamRandomNumbers", count=count, max_value=max_value)

def test_message_stream_random_numbers(count, max_value) -> TestMessage:
    return make_test_message_stream_random_numbers(count, max_value)

def make_test_message_stream_with_delays(count, delay_ms) -> TestMessage:
    return TestMessageStreamWithDelays(kind="StreamWithDelays", count=count, delay_ms=delay_ms)

def test_message_stream_with_delays(count, delay_ms) -> TestMessage:
    return make_test_message_stream_with_delays(count, delay_ms)

def make_test_message_stream_with_errors(count, error_at) -> TestMessage:
    return TestMessageStreamWithErrors(kind="StreamWithErrors", count=count, error_at=error_at)

def test_message_stream_with_errors(count, error_at) -> TestMessage:
    return make_test_message_stream_with_errors(count, error_at)

def make_test_message_stream_large_dataset(count) -> TestMessage:
    return TestMessageStreamLargeDataset(kind="StreamLargeDataset", count=count)

def test_message_stream_large_dataset(count) -> TestMessage:
    return make_test_message_stream_large_dataset(count)

def from_wire_test_message(d: Dict[str, Any]) -> TestMessage:
    if not isinstance(d, dict) or len(d) != 1:
        raise ValueError("Invalid TestMessage wire shape: {!r}".format(d))
    tag, payload = next(iter(d.items()))
    if tag == "CalculatePower":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestMessageCalculatePower(kind="CalculatePower", count=payload.get("count"))
    if tag == "CalculateCategoryBonus":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestMessageCalculateCategoryBonus(kind="CalculateCategoryBonus", category_name=payload.get("category_name"), base_power=payload.get("base_power"))
    if tag == "CalculateCompetitionResult":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestMessageCalculateCompetitionResult(kind="CalculateCompetitionResult", attacker_power=payload.get("attacker_power"), defender_power=payload.get("defender_power"))
    if tag == "CalculateReward":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestMessageCalculateReward(kind="CalculateReward", currency=payload.get("currency"), points=payload.get("points"))
    if tag == "CallbackRoundtrip":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestMessageCallbackRoundtrip(kind="CallbackRoundtrip", value=payload.get("value"))
    if tag == "StreamFibonacci":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestMessageStreamFibonacci(kind="StreamFibonacci", count=payload.get("count"))
    if tag == "StreamRandomNumbers":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestMessageStreamRandomNumbers(kind="StreamRandomNumbers", count=payload.get("count"), max_value=payload.get("max_value"))
    if tag == "StreamWithDelays":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestMessageStreamWithDelays(kind="StreamWithDelays", count=payload.get("count"), delay_ms=payload.get("delay_ms"))
    if tag == "StreamWithErrors":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestMessageStreamWithErrors(kind="StreamWithErrors", count=payload.get("count"), error_at=(payload.get("error_at") if payload.get("error_at") is None else payload.get("error_at")))
    if tag == "StreamLargeDataset":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestMessageStreamLargeDataset(kind="StreamLargeDataset", count=payload.get("count"))
    raise ValueError(f"Unknown TestMessage tag: {tag!r}")

def to_wire_test_message(m: TestMessage) -> Dict[str, Any]:
    if isinstance(m, TestMessageCalculatePower):
        return {"CalculatePower": {"count": m.count}}
    if isinstance(m, TestMessageCalculateCategoryBonus):
        return {"CalculateCategoryBonus": {"category_name": m.category_name, "base_power": m.base_power}}
    if isinstance(m, TestMessageCalculateCompetitionResult):
        return {"CalculateCompetitionResult": {"attacker_power": m.attacker_power, "defender_power": m.defender_power}}
    if isinstance(m, TestMessageCalculateReward):
        return {"CalculateReward": {"currency": m.currency, "points": m.points}}
    if isinstance(m, TestMessageCallbackRoundtrip):
        return {"CallbackRoundtrip": {"value": m.value}}
    if isinstance(m, TestMessageStreamFibonacci):
        return {"StreamFibonacci": {"count": m.count}}
    if isinstance(m, TestMessageStreamRandomNumbers):
        return {"StreamRandomNumbers": {"count": m.count, "max_value": m.max_value}}
    if isinstance(m, TestMessageStreamWithDelays):
        return {"StreamWithDelays": {"count": m.count, "delay_ms": m.delay_ms}}
    if isinstance(m, TestMessageStreamWithErrors):
        return {"StreamWithErrors": {"count": m.count, "error_at": (m.error_at if m.error_at is None else m.error_at)}}
    if isinstance(m, TestMessageStreamLargeDataset):
        return {"StreamLargeDataset": {"count": m.count}}
    raise TypeError(f"Not a TestMessage instance: {m!r}")

class TestMessageHandlers(TypedDict, total=False):
    CalculatePower: Callable[[int], R]
    CalculateCategoryBonus: Callable[[str, int], R]
    CalculateCompetitionResult: Callable[[int, int], R]
    CalculateReward: Callable[[int, int], R]
    CallbackRoundtrip: Callable[[int], R]
    StreamFibonacci: Callable[[int], R]
    StreamRandomNumbers: Callable[[int, int], R]
    StreamWithDelays: Callable[[int, int], R]
    StreamWithErrors: Callable[[int, Optional[int]], R]
    StreamLargeDataset: Callable[[int], R]
    default: Callable[[TestMessage], R]
def match_test_message(m: TestMessage, **handlers: Unpack[TestMessageHandlers]) -> Any:
    if isinstance(m, TestMessageCalculatePower):
        fn = handlers.get("CalculatePower")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for CalculatePower"))
        return fn(m.count)
    if isinstance(m, TestMessageCalculateCategoryBonus):
        fn = handlers.get("CalculateCategoryBonus")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for CalculateCategoryBonus"))
        return fn(m.category_name, m.base_power)
    if isinstance(m, TestMessageCalculateCompetitionResult):
        fn = handlers.get("CalculateCompetitionResult")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for CalculateCompetitionResult"))
        return fn(m.attacker_power, m.defender_power)
    if isinstance(m, TestMessageCalculateReward):
        fn = handlers.get("CalculateReward")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for CalculateReward"))
        return fn(m.currency, m.points)
    if isinstance(m, TestMessageCallbackRoundtrip):
        fn = handlers.get("CallbackRoundtrip")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for CallbackRoundtrip"))
        return fn(m.value)
    if isinstance(m, TestMessageStreamFibonacci):
        fn = handlers.get("StreamFibonacci")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for StreamFibonacci"))
        return fn(m.count)
    if isinstance(m, TestMessageStreamRandomNumbers):
        fn = handlers.get("StreamRandomNumbers")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for StreamRandomNumbers"))
        return fn(m.count, m.max_value)
    if isinstance(m, TestMessageStreamWithDelays):
        fn = handlers.get("StreamWithDelays")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for StreamWithDelays"))
        return fn(m.count, m.delay_ms)
    if isinstance(m, TestMessageStreamWithErrors):
        fn = handlers.get("StreamWithErrors")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for StreamWithErrors"))
        return fn(m.count, m.error_at)
    if isinstance(m, TestMessageStreamLargeDataset):
        fn = handlers.get("StreamLargeDataset")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for StreamLargeDataset"))
        return fn(m.count)
    default = handlers.get("default")
    return default(m) if default else (_ for _ in ()).throw(TypeError("No matching handler"))
def decode_test_message(tag: str, payload: Any) -> TestMessage:
    if tag == "CalculatePower":
        return TestMessageCalculatePower(kind="CalculatePower", count=payload.get("count"))
    if tag == "CalculateCategoryBonus":
        return TestMessageCalculateCategoryBonus(kind="CalculateCategoryBonus", category_name=payload.get("category_name"), base_power=payload.get("base_power"))
    if tag == "CalculateCompetitionResult":
        return TestMessageCalculateCompetitionResult(kind="CalculateCompetitionResult", attacker_power=payload.get("attacker_power"), defender_power=payload.get("defender_power"))
    if tag == "CalculateReward":
        return TestMessageCalculateReward(kind="CalculateReward", currency=payload.get("currency"), points=payload.get("points"))
    if tag == "CallbackRoundtrip":
        return TestMessageCallbackRoundtrip(kind="CallbackRoundtrip", value=payload.get("value"))
    if tag == "StreamFibonacci":
        return TestMessageStreamFibonacci(kind="StreamFibonacci", count=payload.get("count"))
    if tag == "StreamRandomNumbers":
        return TestMessageStreamRandomNumbers(kind="StreamRandomNumbers", count=payload.get("count"), max_value=payload.get("max_value"))
    if tag == "StreamWithDelays":
        return TestMessageStreamWithDelays(kind="StreamWithDelays", count=payload.get("count"), delay_ms=payload.get("delay_ms"))
    if tag == "StreamWithErrors":
        return TestMessageStreamWithErrors(kind="StreamWithErrors", count=payload.get("count"), error_at=(payload.get("error_at") if payload.get("error_at") is None else payload.get("error_at")))
    if tag == "StreamLargeDataset":
        return TestMessageStreamLargeDataset(kind="StreamLargeDataset", count=payload.get("count"))
    raise ValueError(f"Unknown TestMessage tag: {tag!r}")

@dataclass
class TestResponsePower:
    kind: Literal["Power"]
    power: int

@dataclass
class TestResponseCategoryBonus:
    kind: Literal["CategoryBonus"]
    bonus: int

@dataclass
class TestResponseCompetitionResult:
    kind: Literal["CompetitionResult"]
    victory: bool

@dataclass
class TestResponseRewardResult:
    kind: Literal["RewardResult"]
    total_currency: int
    bonus_currency: int

@dataclass
class TestResponseCallbackRoundtripResult:
    kind: Literal["CallbackRoundtripResult"]
    value: int

@dataclass
class TestResponseStreamItem:
    kind: Literal["StreamItem"]
    index: int
    value: int

@dataclass
class TestResponseStreamError:
    kind: Literal["StreamError"]
    index: int
    error: str

@dataclass
class TestResponseStreamComplete:
    kind: Literal["StreamComplete"]
    total_items: int

TestResponse = Union[TestResponsePower, TestResponseCategoryBonus, TestResponseCompetitionResult, TestResponseRewardResult, TestResponseCallbackRoundtripResult, TestResponseStreamItem, TestResponseStreamError, TestResponseStreamComplete]
R = TypeVar("R")
def is_test_response_power(m: TestResponse) -> TypeGuard[TestResponsePower]:
    return isinstance(m, TestResponsePower)

def expect_test_response_power(m: TestResponse) -> TestResponsePower:
    if not isinstance(m, TestResponsePower):
        raise TypeError(f"Expected TestResponsePower, got {m!r}")
    return m

def is_test_response_category_bonus(m: TestResponse) -> TypeGuard[TestResponseCategoryBonus]:
    return isinstance(m, TestResponseCategoryBonus)

def expect_test_response_category_bonus(m: TestResponse) -> TestResponseCategoryBonus:
    if not isinstance(m, TestResponseCategoryBonus):
        raise TypeError(f"Expected TestResponseCategoryBonus, got {m!r}")
    return m

def is_test_response_competition_result(m: TestResponse) -> TypeGuard[TestResponseCompetitionResult]:
    return isinstance(m, TestResponseCompetitionResult)

def expect_test_response_competition_result(m: TestResponse) -> TestResponseCompetitionResult:
    if not isinstance(m, TestResponseCompetitionResult):
        raise TypeError(f"Expected TestResponseCompetitionResult, got {m!r}")
    return m

def is_test_response_reward_result(m: TestResponse) -> TypeGuard[TestResponseRewardResult]:
    return isinstance(m, TestResponseRewardResult)

def expect_test_response_reward_result(m: TestResponse) -> TestResponseRewardResult:
    if not isinstance(m, TestResponseRewardResult):
        raise TypeError(f"Expected TestResponseRewardResult, got {m!r}")
    return m

def is_test_response_callback_roundtrip_result(m: TestResponse) -> TypeGuard[TestResponseCallbackRoundtripResult]:
    return isinstance(m, TestResponseCallbackRoundtripResult)

def expect_test_response_callback_roundtrip_result(m: TestResponse) -> TestResponseCallbackRoundtripResult:
    if not isinstance(m, TestResponseCallbackRoundtripResult):
        raise TypeError(f"Expected TestResponseCallbackRoundtripResult, got {m!r}")
    return m

def is_test_response_stream_item(m: TestResponse) -> TypeGuard[TestResponseStreamItem]:
    return isinstance(m, TestResponseStreamItem)

def expect_test_response_stream_item(m: TestResponse) -> TestResponseStreamItem:
    if not isinstance(m, TestResponseStreamItem):
        raise TypeError(f"Expected TestResponseStreamItem, got {m!r}")
    return m

def is_test_response_stream_error(m: TestResponse) -> TypeGuard[TestResponseStreamError]:
    return isinstance(m, TestResponseStreamError)

def expect_test_response_stream_error(m: TestResponse) -> TestResponseStreamError:
    if not isinstance(m, TestResponseStreamError):
        raise TypeError(f"Expected TestResponseStreamError, got {m!r}")
    return m

def is_test_response_stream_complete(m: TestResponse) -> TypeGuard[TestResponseStreamComplete]:
    return isinstance(m, TestResponseStreamComplete)

def expect_test_response_stream_complete(m: TestResponse) -> TestResponseStreamComplete:
    if not isinstance(m, TestResponseStreamComplete):
        raise TypeError(f"Expected TestResponseStreamComplete, got {m!r}")
    return m

def make_test_response_power(power) -> TestResponse:
    return TestResponsePower(kind="Power", power=power)

def test_response_power(power) -> TestResponse:
    return make_test_response_power(power)

def make_test_response_category_bonus(bonus) -> TestResponse:
    return TestResponseCategoryBonus(kind="CategoryBonus", bonus=bonus)

def test_response_category_bonus(bonus) -> TestResponse:
    return make_test_response_category_bonus(bonus)

def make_test_response_competition_result(victory) -> TestResponse:
    return TestResponseCompetitionResult(kind="CompetitionResult", victory=victory)

def test_response_competition_result(victory) -> TestResponse:
    return make_test_response_competition_result(victory)

def make_test_response_reward_result(total_currency, bonus_currency) -> TestResponse:
    return TestResponseRewardResult(kind="RewardResult", total_currency=total_currency, bonus_currency=bonus_currency)

def test_response_reward_result(total_currency, bonus_currency) -> TestResponse:
    return make_test_response_reward_result(total_currency, bonus_currency)

def make_test_response_callback_roundtrip_result(value) -> TestResponse:
    return TestResponseCallbackRoundtripResult(kind="CallbackRoundtripResult", value=value)

def test_response_callback_roundtrip_result(value) -> TestResponse:
    return make_test_response_callback_roundtrip_result(value)

def make_test_response_stream_item(index, value) -> TestResponse:
    return TestResponseStreamItem(kind="StreamItem", index=index, value=value)

def test_response_stream_item(index, value) -> TestResponse:
    return make_test_response_stream_item(index, value)

def make_test_response_stream_error(index, error) -> TestResponse:
    return TestResponseStreamError(kind="StreamError", index=index, error=error)

def test_response_stream_error(index, error) -> TestResponse:
    return make_test_response_stream_error(index, error)

def make_test_response_stream_complete(total_items) -> TestResponse:
    return TestResponseStreamComplete(kind="StreamComplete", total_items=total_items)

def test_response_stream_complete(total_items) -> TestResponse:
    return make_test_response_stream_complete(total_items)

def from_wire_test_response(d: Dict[str, Any]) -> TestResponse:
    if not isinstance(d, dict) or len(d) != 1:
        raise ValueError("Invalid TestResponse wire shape: {!r}".format(d))
    tag, payload = next(iter(d.items()))
    if tag == "Power":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestResponsePower(kind="Power", power=payload.get("power"))
    if tag == "CategoryBonus":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestResponseCategoryBonus(kind="CategoryBonus", bonus=payload.get("bonus"))
    if tag == "CompetitionResult":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestResponseCompetitionResult(kind="CompetitionResult", victory=payload.get("victory"))
    if tag == "RewardResult":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestResponseRewardResult(kind="RewardResult", total_currency=payload.get("total_currency"), bonus_currency=payload.get("bonus_currency"))
    if tag == "CallbackRoundtripResult":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestResponseCallbackRoundtripResult(kind="CallbackRoundtripResult", value=payload.get("value"))
    if tag == "StreamItem":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestResponseStreamItem(kind="StreamItem", index=payload.get("index"), value=payload.get("value"))
    if tag == "StreamError":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestResponseStreamError(kind="StreamError", index=payload.get("index"), error=payload.get("error"))
    if tag == "StreamComplete":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TestResponseStreamComplete(kind="StreamComplete", total_items=payload.get("total_items"))
    raise ValueError(f"Unknown TestResponse tag: {tag!r}")

def to_wire_test_response(m: TestResponse) -> Dict[str, Any]:
    if isinstance(m, TestResponsePower):
        return {"Power": {"power": m.power}}
    if isinstance(m, TestResponseCategoryBonus):
        return {"CategoryBonus": {"bonus": m.bonus}}
    if isinstance(m, TestResponseCompetitionResult):
        return {"CompetitionResult": {"victory": m.victory}}
    if isinstance(m, TestResponseRewardResult):
        return {"RewardResult": {"total_currency": m.total_currency, "bonus_currency": m.bonus_currency}}
    if isinstance(m, TestResponseCallbackRoundtripResult):
        return {"CallbackRoundtripResult": {"value": m.value}}
    if isinstance(m, TestResponseStreamItem):
        return {"StreamItem": {"index": m.index, "value": m.value}}
    if isinstance(m, TestResponseStreamError):
        return {"StreamError": {"index": m.index, "error": m.error}}
    if isinstance(m, TestResponseStreamComplete):
        return {"StreamComplete": {"total_items": m.total_items}}
    raise TypeError(f"Not a TestResponse instance: {m!r}")

class TestResponseHandlers(TypedDict, total=False):
    Power: Callable[[int], R]
    CategoryBonus: Callable[[int], R]
    CompetitionResult: Callable[[bool], R]
    RewardResult: Callable[[int, int], R]
    CallbackRoundtripResult: Callable[[int], R]
    StreamItem: Callable[[int, int], R]
    StreamError: Callable[[int, str], R]
    StreamComplete: Callable[[int], R]
    default: Callable[[TestResponse], R]
def match_test_response(m: TestResponse, **handlers: Unpack[TestResponseHandlers]) -> Any:
    if isinstance(m, TestResponsePower):
        fn = handlers.get("Power")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for Power"))
        return fn(m.power)
    if isinstance(m, TestResponseCategoryBonus):
        fn = handlers.get("CategoryBonus")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for CategoryBonus"))
        return fn(m.bonus)
    if isinstance(m, TestResponseCompetitionResult):
        fn = handlers.get("CompetitionResult")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for CompetitionResult"))
        return fn(m.victory)
    if isinstance(m, TestResponseRewardResult):
        fn = handlers.get("RewardResult")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for RewardResult"))
        return fn(m.total_currency, m.bonus_currency)
    if isinstance(m, TestResponseCallbackRoundtripResult):
        fn = handlers.get("CallbackRoundtripResult")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for CallbackRoundtripResult"))
        return fn(m.value)
    if isinstance(m, TestResponseStreamItem):
        fn = handlers.get("StreamItem")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for StreamItem"))
        return fn(m.index, m.value)
    if isinstance(m, TestResponseStreamError):
        fn = handlers.get("StreamError")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for StreamError"))
        return fn(m.index, m.error)
    if isinstance(m, TestResponseStreamComplete):
        fn = handlers.get("StreamComplete")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for StreamComplete"))
        return fn(m.total_items)
    default = handlers.get("default")
    return default(m) if default else (_ for _ in ()).throw(TypeError("No matching handler"))
def decode_test_response(tag: str, payload: Any) -> TestResponse:
    if tag == "Power":
        return TestResponsePower(kind="Power", power=payload.get("power"))
    if tag == "CategoryBonus":
        return TestResponseCategoryBonus(kind="CategoryBonus", bonus=payload.get("bonus"))
    if tag == "CompetitionResult":
        return TestResponseCompetitionResult(kind="CompetitionResult", victory=payload.get("victory"))
    if tag == "RewardResult":
        return TestResponseRewardResult(kind="RewardResult", total_currency=payload.get("total_currency"), bonus_currency=payload.get("bonus_currency"))
    if tag == "CallbackRoundtripResult":
        return TestResponseCallbackRoundtripResult(kind="CallbackRoundtripResult", value=payload.get("value"))
    if tag == "StreamItem":
        return TestResponseStreamItem(kind="StreamItem", index=payload.get("index"), value=payload.get("value"))
    if tag == "StreamError":
        return TestResponseStreamError(kind="StreamError", index=payload.get("index"), error=payload.get("error"))
    if tag == "StreamComplete":
        return TestResponseStreamComplete(kind="StreamComplete", total_items=payload.get("total_items"))
    raise ValueError(f"Unknown TestResponse tag: {tag!r}")

