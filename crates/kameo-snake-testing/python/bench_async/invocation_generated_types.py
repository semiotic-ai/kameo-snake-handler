# Generated by kameo-snake-handler codegen. Do not edit.
# package: invocation_generated_types
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Union, Literal, List, Dict, Any, Callable, TypeVar, TypedDict, Unpack
try:
    from typing import TypeGuard  # Python 3.10+
except ImportError:
    from typing_extensions import TypeGuard  # fallback

class BenchMessage: ...
class BenchResponse: ...

@dataclass
class BenchMessage:
    id: int
    py_sleep_ms: int
    rust_sleep_ms: int
def make_bench_message(id, py_sleep_ms, rust_sleep_ms) -> BenchMessage:
    return BenchMessage(id=id, py_sleep_ms=py_sleep_ms, rust_sleep_ms=rust_sleep_ms)
def from_wire_bench_message(d: Dict[str, Any]) -> BenchMessage:
    if not isinstance(d, dict):
        raise ValueError("Invalid BenchMessage wire shape: expected dict")
    return BenchMessage(id=d.get("id"), py_sleep_ms=d.get("py_sleep_ms"), rust_sleep_ms=d.get("rust_sleep_ms"))
def to_wire_bench_message(m: BenchMessage) -> Dict[str, Any]:
    return {"id": m.id, "py_sleep_ms": m.py_sleep_ms, "rust_sleep_ms": m.rust_sleep_ms}
def from_wire_bench_message_strict(d: Dict[str, Any]) -> BenchMessage:
    if not isinstance(d, dict):
        raise ValueError("Invalid BenchMessage wire shape: expected dict")
    allowed = {"id", "py_sleep_ms", "rust_sleep_ms"}
    unknown = set(d.keys()) - allowed
    if unknown:
        raise ValueError("Unknown keys for BenchMessage: " + repr(unknown))
    return from_wire_bench_message(d)

@dataclass
class BenchResponsePower:
    kind: Literal["Power"]
    power: int

@dataclass
class BenchResponseCategoryBonus:
    kind: Literal["CategoryBonus"]
    bonus: int

@dataclass
class BenchResponseCompetitionResult:
    kind: Literal["CompetitionResult"]
    victory: bool

@dataclass
class BenchResponseRewardResult:
    kind: Literal["RewardResult"]
    total_currency: int
    bonus_currency: int

@dataclass
class BenchResponseCallbackRoundtripResult:
    kind: Literal["CallbackRoundtripResult"]
    value: int

BenchResponse = Union[BenchResponsePower, BenchResponseCategoryBonus, BenchResponseCompetitionResult, BenchResponseRewardResult, BenchResponseCallbackRoundtripResult]
R = TypeVar("R")
def is_bench_response_power(m: BenchResponse) -> TypeGuard[BenchResponsePower]:
    return isinstance(m, BenchResponsePower)

def expect_bench_response_power(m: BenchResponse) -> BenchResponsePower:
    if not isinstance(m, BenchResponsePower):
        raise TypeError(f"Expected BenchResponsePower, got {m!r}")
    return m

def is_bench_response_category_bonus(m: BenchResponse) -> TypeGuard[BenchResponseCategoryBonus]:
    return isinstance(m, BenchResponseCategoryBonus)

def expect_bench_response_category_bonus(m: BenchResponse) -> BenchResponseCategoryBonus:
    if not isinstance(m, BenchResponseCategoryBonus):
        raise TypeError(f"Expected BenchResponseCategoryBonus, got {m!r}")
    return m

def is_bench_response_competition_result(m: BenchResponse) -> TypeGuard[BenchResponseCompetitionResult]:
    return isinstance(m, BenchResponseCompetitionResult)

def expect_bench_response_competition_result(m: BenchResponse) -> BenchResponseCompetitionResult:
    if not isinstance(m, BenchResponseCompetitionResult):
        raise TypeError(f"Expected BenchResponseCompetitionResult, got {m!r}")
    return m

def is_bench_response_reward_result(m: BenchResponse) -> TypeGuard[BenchResponseRewardResult]:
    return isinstance(m, BenchResponseRewardResult)

def expect_bench_response_reward_result(m: BenchResponse) -> BenchResponseRewardResult:
    if not isinstance(m, BenchResponseRewardResult):
        raise TypeError(f"Expected BenchResponseRewardResult, got {m!r}")
    return m

def is_bench_response_callback_roundtrip_result(m: BenchResponse) -> TypeGuard[BenchResponseCallbackRoundtripResult]:
    return isinstance(m, BenchResponseCallbackRoundtripResult)

def expect_bench_response_callback_roundtrip_result(m: BenchResponse) -> BenchResponseCallbackRoundtripResult:
    if not isinstance(m, BenchResponseCallbackRoundtripResult):
        raise TypeError(f"Expected BenchResponseCallbackRoundtripResult, got {m!r}")
    return m

def make_bench_response_power(power) -> BenchResponse:
    return BenchResponsePower(kind="Power", power=power)

def bench_response_power(power) -> BenchResponse:
    return make_bench_response_power(power)

def make_bench_response_category_bonus(bonus) -> BenchResponse:
    return BenchResponseCategoryBonus(kind="CategoryBonus", bonus=bonus)

def bench_response_category_bonus(bonus) -> BenchResponse:
    return make_bench_response_category_bonus(bonus)

def make_bench_response_competition_result(victory) -> BenchResponse:
    return BenchResponseCompetitionResult(kind="CompetitionResult", victory=victory)

def bench_response_competition_result(victory) -> BenchResponse:
    return make_bench_response_competition_result(victory)

def make_bench_response_reward_result(total_currency, bonus_currency) -> BenchResponse:
    return BenchResponseRewardResult(kind="RewardResult", total_currency=total_currency, bonus_currency=bonus_currency)

def bench_response_reward_result(total_currency, bonus_currency) -> BenchResponse:
    return make_bench_response_reward_result(total_currency, bonus_currency)

def make_bench_response_callback_roundtrip_result(value) -> BenchResponse:
    return BenchResponseCallbackRoundtripResult(kind="CallbackRoundtripResult", value=value)

def bench_response_callback_roundtrip_result(value) -> BenchResponse:
    return make_bench_response_callback_roundtrip_result(value)

def from_wire_bench_response(d: Dict[str, Any]) -> BenchResponse:
    if not isinstance(d, dict) or len(d) != 1:
        raise ValueError("Invalid BenchResponse wire shape: {!r}".format(d))
    tag, payload = next(iter(d.items()))
    if tag == "Power":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return BenchResponsePower(kind="Power", power=payload.get("power"))
    if tag == "CategoryBonus":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return BenchResponseCategoryBonus(kind="CategoryBonus", bonus=payload.get("bonus"))
    if tag == "CompetitionResult":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return BenchResponseCompetitionResult(kind="CompetitionResult", victory=payload.get("victory"))
    if tag == "RewardResult":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return BenchResponseRewardResult(kind="RewardResult", total_currency=payload.get("total_currency"), bonus_currency=payload.get("bonus_currency"))
    if tag == "CallbackRoundtripResult":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return BenchResponseCallbackRoundtripResult(kind="CallbackRoundtripResult", value=payload.get("value"))
    raise ValueError(f"Unknown BenchResponse tag: {tag!r}")

def to_wire_bench_response(m: BenchResponse) -> Dict[str, Any]:
    if isinstance(m, BenchResponsePower):
        return {"Power": {"power": m.power}}
    if isinstance(m, BenchResponseCategoryBonus):
        return {"CategoryBonus": {"bonus": m.bonus}}
    if isinstance(m, BenchResponseCompetitionResult):
        return {"CompetitionResult": {"victory": m.victory}}
    if isinstance(m, BenchResponseRewardResult):
        return {"RewardResult": {"total_currency": m.total_currency, "bonus_currency": m.bonus_currency}}
    if isinstance(m, BenchResponseCallbackRoundtripResult):
        return {"CallbackRoundtripResult": {"value": m.value}}
    raise TypeError(f"Not a BenchResponse instance: {m!r}")

class BenchResponseHandlers(TypedDict, total=False):
    Power: Callable[[int], R]
    CategoryBonus: Callable[[int], R]
    CompetitionResult: Callable[[bool], R]
    RewardResult: Callable[[int, int], R]
    CallbackRoundtripResult: Callable[[int], R]
    default: Callable[[BenchResponse], R]
def match_bench_response(m: BenchResponse, **handlers: Unpack[BenchResponseHandlers]) -> Any:
    if isinstance(m, BenchResponsePower):
        fn = handlers.get("Power")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for Power"))
        return fn(m.power)
    if isinstance(m, BenchResponseCategoryBonus):
        fn = handlers.get("CategoryBonus")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for CategoryBonus"))
        return fn(m.bonus)
    if isinstance(m, BenchResponseCompetitionResult):
        fn = handlers.get("CompetitionResult")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for CompetitionResult"))
        return fn(m.victory)
    if isinstance(m, BenchResponseRewardResult):
        fn = handlers.get("RewardResult")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for RewardResult"))
        return fn(m.total_currency, m.bonus_currency)
    if isinstance(m, BenchResponseCallbackRoundtripResult):
        fn = handlers.get("CallbackRoundtripResult")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for CallbackRoundtripResult"))
        return fn(m.value)
    default = handlers.get("default")
    return default(m) if default else (_ for _ in ()).throw(TypeError("No matching handler"))
def decode_bench_response(tag: str, payload: Any) -> BenchResponse:
    if tag == "Power":
        return BenchResponsePower(kind="Power", power=payload.get("power"))
    if tag == "CategoryBonus":
        return BenchResponseCategoryBonus(kind="CategoryBonus", bonus=payload.get("bonus"))
    if tag == "CompetitionResult":
        return BenchResponseCompetitionResult(kind="CompetitionResult", victory=payload.get("victory"))
    if tag == "RewardResult":
        return BenchResponseRewardResult(kind="RewardResult", total_currency=payload.get("total_currency"), bonus_currency=payload.get("bonus_currency"))
    if tag == "CallbackRoundtripResult":
        return BenchResponseCallbackRoundtripResult(kind="CallbackRoundtripResult", value=payload.get("value"))
    raise ValueError(f"Unknown BenchResponse tag: {tag!r}")

