# Generated by kameo-snake-handler codegen. Do not edit.
# package: invocation_generated_types
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Union, Literal, List, Dict, Any, Callable, TypeVar, TypedDict, Unpack
try:
    from typing import TypeGuard  # Python 3.10+
except ImportError:
    from typing_extensions import TypeGuard  # fallback

class TraderMessage: ...
class TraderResponse: ...

@dataclass
class TraderMessageOrderDetails:
    kind: Literal["OrderDetails"]
    item: str
    currency: int

TraderMessage = Union[TraderMessageOrderDetails]
R = TypeVar("R")
def is_trader_message_order_details(m: TraderMessage) -> TypeGuard[TraderMessageOrderDetails]:
    return isinstance(m, TraderMessageOrderDetails)

def expect_trader_message_order_details(m: TraderMessage) -> TraderMessageOrderDetails:
    if not isinstance(m, TraderMessageOrderDetails):
        raise TypeError(f"Expected TraderMessageOrderDetails, got {m!r}")
    return m

def make_trader_message_order_details(item, currency) -> TraderMessage:
    return TraderMessageOrderDetails(kind="OrderDetails", item=item, currency=currency)

def trader_message_order_details(item, currency) -> TraderMessage:
    return make_trader_message_order_details(item, currency)

def from_wire_trader_message(d: Dict[str, Any]) -> TraderMessage:
    if not isinstance(d, dict) or len(d) != 1:
        raise ValueError("Invalid TraderMessage wire shape: {!r}".format(d))
    tag, payload = next(iter(d.items()))
    if tag == "OrderDetails":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TraderMessageOrderDetails(kind="OrderDetails", item=payload.get("item"), currency=payload.get("currency"))
    raise ValueError(f"Unknown TraderMessage tag: {tag!r}")

def to_wire_trader_message(m: TraderMessage) -> Dict[str, Any]:
    if isinstance(m, TraderMessageOrderDetails):
        return {"OrderDetails": {"item": m.item, "currency": m.currency}}
    raise TypeError(f"Not a TraderMessage instance: {m!r}")

class TraderMessageHandlers(TypedDict, total=False):
    OrderDetails: Callable[[Any, Any], R]
    default: Callable[[TraderMessage], R]
def match_trader_message(m: TraderMessage, **handlers: Unpack[TraderMessageHandlers]) -> Any:
    if isinstance(m, TraderMessageOrderDetails):
        fn = handlers.get("OrderDetails")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for OrderDetails"))
        return fn(m.item, m.currency)
    default = handlers.get("default")
    return default(m) if default else (_ for _ in ()).throw(TypeError("No matching handler"))
def decode_trader_message(tag: str, payload: Any) -> TraderMessage:
    if tag == "OrderDetails":
        return TraderMessageOrderDetails(kind="OrderDetails", item=payload.get("item"), currency=payload.get("currency"))
    raise ValueError(f"Unknown TraderMessage tag: {tag!r}")

@dataclass
class TraderResponseOrderResult:
    kind: Literal["OrderResult"]
    result: str

@dataclass
class TraderResponseError:
    kind: Literal["Error"]
    error: str

TraderResponse = Union[TraderResponseOrderResult, TraderResponseError]
R = TypeVar("R")
def is_trader_response_order_result(m: TraderResponse) -> TypeGuard[TraderResponseOrderResult]:
    return isinstance(m, TraderResponseOrderResult)

def expect_trader_response_order_result(m: TraderResponse) -> TraderResponseOrderResult:
    if not isinstance(m, TraderResponseOrderResult):
        raise TypeError(f"Expected TraderResponseOrderResult, got {m!r}")
    return m

def is_trader_response_error(m: TraderResponse) -> TypeGuard[TraderResponseError]:
    return isinstance(m, TraderResponseError)

def expect_trader_response_error(m: TraderResponse) -> TraderResponseError:
    if not isinstance(m, TraderResponseError):
        raise TypeError(f"Expected TraderResponseError, got {m!r}")
    return m

def make_trader_response_order_result(result) -> TraderResponse:
    return TraderResponseOrderResult(kind="OrderResult", result=result)

def trader_response_order_result(result) -> TraderResponse:
    return make_trader_response_order_result(result)

def make_trader_response_error(error) -> TraderResponse:
    return TraderResponseError(kind="Error", error=error)

def trader_response_error(error) -> TraderResponse:
    return make_trader_response_error(error)

def from_wire_trader_response(d: Dict[str, Any]) -> TraderResponse:
    if not isinstance(d, dict) or len(d) != 1:
        raise ValueError("Invalid TraderResponse wire shape: {!r}".format(d))
    tag, payload = next(iter(d.items()))
    if tag == "OrderResult":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TraderResponseOrderResult(kind="OrderResult", result=payload.get("result"))
    if tag == "Error":
        if not isinstance(payload, dict):
            raise ValueError("Struct payload must be a dict")
        return TraderResponseError(kind="Error", error=payload.get("error"))
    raise ValueError(f"Unknown TraderResponse tag: {tag!r}")

def to_wire_trader_response(m: TraderResponse) -> Dict[str, Any]:
    if isinstance(m, TraderResponseOrderResult):
        return {"OrderResult": {"result": m.result}}
    if isinstance(m, TraderResponseError):
        return {"Error": {"error": m.error}}
    raise TypeError(f"Not a TraderResponse instance: {m!r}")

class TraderResponseHandlers(TypedDict, total=False):
    OrderResult: Callable[[Any], R]
    Error: Callable[[Any], R]
    default: Callable[[TraderResponse], R]
def match_trader_response(m: TraderResponse, **handlers: Unpack[TraderResponseHandlers]) -> Any:
    if isinstance(m, TraderResponseOrderResult):
        fn = handlers.get("OrderResult")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for OrderResult"))
        return fn(m.result)
    if isinstance(m, TraderResponseError):
        fn = handlers.get("Error")
        if fn is None:
            default = handlers.get("default")
            return default(m) if default else (_ for _ in ()).throw(TypeError("No handler for Error"))
        return fn(m.error)
    default = handlers.get("default")
    return default(m) if default else (_ for _ in ()).throw(TypeError("No matching handler"))
def decode_trader_response(tag: str, payload: Any) -> TraderResponse:
    if tag == "OrderResult":
        return TraderResponseOrderResult(kind="OrderResult", result=payload.get("result"))
    if tag == "Error":
        return TraderResponseError(kind="Error", error=payload.get("error"))
    raise ValueError(f"Unknown TraderResponse tag: {tag!r}")

