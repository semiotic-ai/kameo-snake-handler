# Generated by kameo-snake-handler codegen. Do not edit.
# package: callback_request_types
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Union, Literal, List, Dict, Any, Callable, TypeVar, TypedDict, Unpack
try:
    from typing import TypeGuard  # Python 3.10+
except ImportError:
    from typing_extensions import TypeGuard  # fallback

class TestCallbackMessage: ...
class ComplexCallbackMessage: ...
class Dimensions: ...
class EventItem: ...
class TraderCallbackMessage: ...

@dataclass
class TestCallbackMessage:
    value: int
def make_test_callback_message(value) -> TestCallbackMessage:
    return TestCallbackMessage(value=value)
def from_wire_test_callback_message(d: Dict[str, Any]) -> TestCallbackMessage:
    if not isinstance(d, dict):
        raise ValueError("Invalid TestCallbackMessage wire shape: expected dict")
    return TestCallbackMessage(value=d.get("value"))
def to_wire_test_callback_message(m: TestCallbackMessage) -> Dict[str, Any]:
    return {"value": m.value}
def from_wire_test_callback_message_strict(d: Dict[str, Any]) -> TestCallbackMessage:
    if not isinstance(d, dict):
        raise ValueError("Invalid TestCallbackMessage wire shape: expected dict")
    allowed = {"value"}
    unknown = set(d.keys()) - allowed
    if unknown:
        raise ValueError("Unknown keys for TestCallbackMessage: " + repr(unknown))
    return from_wire_test_callback_message(d)

@dataclass
class ComplexCallbackMessage:
    value: int
    labels: List[str]
    metadata: Dict[str, str]
    dimensions: Optional[Dimensions]
    events: List[EventItem]
def make_complex_callback_message(value, labels, metadata, dimensions, events) -> ComplexCallbackMessage:
    return ComplexCallbackMessage(value=value, labels=labels, metadata=metadata, dimensions=dimensions, events=events)
def from_wire_complex_callback_message(d: Dict[str, Any]) -> ComplexCallbackMessage:
    if not isinstance(d, dict):
        raise ValueError("Invalid ComplexCallbackMessage wire shape: expected dict")
    return ComplexCallbackMessage(value=d.get("value"), labels=[__x for __x in d.get("labels")], metadata={k: __v for (k, __v) in d.get("metadata").items()}, dimensions=(d.get("dimensions") if d.get("dimensions") is None else from_wire_dimensions(d.get("dimensions"))), events=[from_wire_event_item(__x) for __x in d.get("events")])
def to_wire_complex_callback_message(m: ComplexCallbackMessage) -> Dict[str, Any]:
    return {"value": m.value, "labels": [__x for __x in m.labels], "metadata": {k: __v for (k, __v) in m.metadata.items()}, "dimensions": (m.dimensions if m.dimensions is None else to_wire_dimensions(m.dimensions)), "events": [to_wire_event_item(__x) for __x in m.events]}
def from_wire_complex_callback_message_strict(d: Dict[str, Any]) -> ComplexCallbackMessage:
    if not isinstance(d, dict):
        raise ValueError("Invalid ComplexCallbackMessage wire shape: expected dict")
    allowed = {"value", "labels", "metadata", "dimensions", "events"}
    unknown = set(d.keys()) - allowed
    if unknown:
        raise ValueError("Unknown keys for ComplexCallbackMessage: " + repr(unknown))
    return from_wire_complex_callback_message(d)

@dataclass
class Dimensions:
    width: int
    height: int
def make_dimensions(width, height) -> Dimensions:
    return Dimensions(width=width, height=height)
def from_wire_dimensions(d: Dict[str, Any]) -> Dimensions:
    if not isinstance(d, dict):
        raise ValueError("Invalid Dimensions wire shape: expected dict")
    return Dimensions(width=d.get("width"), height=d.get("height"))
def to_wire_dimensions(m: Dimensions) -> Dict[str, Any]:
    return {"width": m.width, "height": m.height}
def from_wire_dimensions_strict(d: Dict[str, Any]) -> Dimensions:
    if not isinstance(d, dict):
        raise ValueError("Invalid Dimensions wire shape: expected dict")
    allowed = {"width", "height"}
    unknown = set(d.keys()) - allowed
    if unknown:
        raise ValueError("Unknown keys for Dimensions: " + repr(unknown))
    return from_wire_dimensions(d)

@dataclass
class EventItem:
    kind: str
    weight: int
def make_event_item(kind, weight) -> EventItem:
    return EventItem(kind=kind, weight=weight)
def from_wire_event_item(d: Dict[str, Any]) -> EventItem:
    if not isinstance(d, dict):
        raise ValueError("Invalid EventItem wire shape: expected dict")
    return EventItem(kind=d.get("kind"), weight=d.get("weight"))
def to_wire_event_item(m: EventItem) -> Dict[str, Any]:
    return {"kind": m.kind, "weight": m.weight}
def from_wire_event_item_strict(d: Dict[str, Any]) -> EventItem:
    if not isinstance(d, dict):
        raise ValueError("Invalid EventItem wire shape: expected dict")
    allowed = {"kind", "weight"}
    unknown = set(d.keys()) - allowed
    if unknown:
        raise ValueError("Unknown keys for EventItem: " + repr(unknown))
    return from_wire_event_item(d)

@dataclass
class TraderCallbackMessage:
    value: int
def make_trader_callback_message(value) -> TraderCallbackMessage:
    return TraderCallbackMessage(value=value)
def from_wire_trader_callback_message(d: Dict[str, Any]) -> TraderCallbackMessage:
    if not isinstance(d, dict):
        raise ValueError("Invalid TraderCallbackMessage wire shape: expected dict")
    return TraderCallbackMessage(value=d.get("value"))
def to_wire_trader_callback_message(m: TraderCallbackMessage) -> Dict[str, Any]:
    return {"value": m.value}
def from_wire_trader_callback_message_strict(d: Dict[str, Any]) -> TraderCallbackMessage:
    if not isinstance(d, dict):
        raise ValueError("Invalid TraderCallbackMessage wire shape: expected dict")
    allowed = {"value"}
    unknown = set(d.keys()) - allowed
    if unknown:
        raise ValueError("Unknown keys for TraderCallbackMessage: " + repr(unknown))
    return from_wire_trader_callback_message(d)

